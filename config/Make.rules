# **********************************************************************
#
# Copyright (c) 2003-2015 ZeroC, Inc. All rights reserved.
#
# This copy of Ice Touch is licensed to you under the terms described in the
# ICE_TOUCH_LICENSE file included in this distribution.
#
# **********************************************************************

#
# Select an installation base directory. The directory will be created
# if it does not exist.
#
prefix			?= /Library/Developer/IceTouch-$(VERSION)

#
# Xcode root directory. If you have several Xcode versions installed,
# choose the version you want to use to build Ice Touch. The default
# is the one returned by "xcode-select -print-path".
#
#XCODE_PATH          = /Applications/Xcode.app

#
# Define OPTIMIZE_SIZE as yes if you want to build with minimal size.
# Define OPTIMIZE_SPEED as yes if you want to build with maximum speed.
#
# These options are mutually exclusive. If neither is set, Ice Touch
# is built with debug information.
#
#OPTIMIZE_SIZE		= yes
#OPTIMIZE_SPEED		= yes

#
# The default is to build the slice2cpp and slice2objc translators if
# you don't define COMPILE_FOR_IPHONE, COMPILE_FOR_IPHONE_SIMULATOR or
# COMPILE_FOR_OSX below.
#

#
# Compile the Xcode SDK for the iPhone platform
#
#COMPILE_FOR_IPHONE		= yes

#
# Compile the Xcode SDK for the iPhone simulator platform
#
#COMPILE_FOR_IPHONE_SIMULATOR 	= yes

#
# Compile the Xcode SDK for OS X platform
#
#COMPILE_FOR_OSX 	        = yes

#
# The minimum SDK version supported by targets, the default is 7.1
# to allow using Ice Touch binaries on older iOS versions.
#
#IOS_TARGET_MIN_SDK_VERSION = 7.1

#
# The build architectures. The default is to build fat binaries with all
# supported architectures for release builds, and single arch binaries
# for debug builds. The list of supported architecturs depends of the
# target platform.
#
# Cocoa / OS X:
#
#ARCHFLAGS            = -arch x86_64
#
# iPhone:
#
#ARCHFLAGS            = -arch armv7 -arch armv7s -arch arm64
#
# iPhone Simulator:
#
#ARCHFLAGS            = -arch i386 -arch x86_64


# ----------------------------------------------------------------------
# Don't change anything below this line!
# ----------------------------------------------------------------------

ifeq ($(ice_language),)
ifneq ($(strip $(foreach s,src/objc test/objc,$(findstring $(s),$(CURDIR)))),)
ice_language = objc
else
ice_language = cpp
endif
endif

ifeq ($(ice_language),cpp)
	sdksubdir = Cpp
else ifeq ($(ice_language),objc)
	sdksubdir = ObjC
else
$(error unknown language for SDK)
endif

include $(top_srcdir)/config/Make.common.rules

LDFLAGS		= $(LDPLATFORMFLAGS) $(COMPFLAGS)
ifeq ($(ice_language),objc)
LDFLAGS		+= -ObjC
endif

ifeq ($(COMPILE_FOR_IPHONE),yes)
ICE_OS_LIBS     = -framework UIKit -framework CFNetwork -framework Security -framework Foundation -liconv
else ifeq ($(COMPILE_FOR_OSX),yes)
ICE_OS_LIBS     = -framework Security -framework Foundation -lbz2 -liconv
endif

ifeq ($(MCPP_LIBS),)
	ifeq ($(MCPP_HOME),)
		#
		# If libmcpp.a is in the third-party subdirectory, we are building the core C++ distribution
		# and we used that mcpp package.
		#
		ifneq ($(wildcard ../../../third-party/mcpp/lib/libmcpp.a),)
			MCPP_HOME = ../../../third-party/mcpp
		endif
	endif
	MCPP_LIBS              = $(if $(MCPP_HOME),-L$(MCPP_HOME)/$(libsubdir)) -lmcpp
endif

LIBS            = -L$(libdir) $(if $(ice_language:cpp=),-lIceObjC,-lIce) $(ICE_OS_LIBS)
TEST_LIBS		= -L$(top_srcdir)/test/lib -lTestCommon $(LIBS)

EVERYTHING		= all depend clean install
EVERYTHING_EXCEPT_ALL   = depend clean install

.SUFFIXES:
.SUFFIXES:		.m .mm .cpp .o

dependdir 	= $(OBJDIR)/.depend
cppdir	  	= $(ice_dir)/cpp
objcdir	  	= $(ice_dir)/objc
langdir	  	= $(ice_dir)/$(ice_language)
langext		= $(if $(ice_language:cpp=),m,cpp)

ifneq ($(HEADERS),)
HEADERS := $(addprefix $(includedir)/,$(HEADERS))
endif

ifneq ($(SRCS),)
SRCS 	:= $(addprefix $(langdir)/src/,$(SRCS))
endif

#
# If we are building tests, we derive the C++ sources from the object
# list specified in the C++ Makefile
#
ifneq ($(findstring test/,$(CURDIR)),)

gettestdir	= $(if $(subst $(ice_language),,$(lastword $1)),$(call gettestdir,$(wordlist 2,$(words $1),x $1))/$(lastword $1),test)
testdir		= $(langdir)/$(call gettestdir,$(subst /, ,$(CURDIR)))

SRCS		:= $(addprefix $(testdir)/,$(subst .o,.$(langext),$(filter-out $(SLICE_OBJS),$(OBJS))))
OBJS		:= $(addprefix $(OBJDIR)/,$(OBJS))

TEST_SLICE_SRCS += $(addprefix $(testdir)/,$(SLICE_OBJS:.o=.ice))
HEADERS 		+= $(patsubst $(testdir)/%.ice,$(OBJDIR)/include/%.h,$(TEST_SLICE_SRCS))
SRCS    		+= $(patsubst $(testdir)/%.ice,$(OBJDIR)/%.$(langext),$(TEST_SLICE_SRCS))

endif

#
# If SLICE_DIRS is specified, add the $(slicedir)/DIR/*.ice Slice
# files to the SLICE_SRCS variable and compute the derived headers and
# sources to add them to HEADERS/SRCS.
#
ifneq ($(SLICE_DIRS),)
SLICE_SRCS += $(foreach sdir,$(SLICE_DIRS),$(wildcard $(slicedir)/$(sdir)/*.ice))

ifneq ($(SLICE_SRCS),)
HEADERS += $(patsubst $(slicedir)/%.ice,$(includedir)$(if $(ice_language:cpp=),/objc,)/%.h,$(SLICE_SRCS))
SRCS    += $(patsubst $(slicedir)/%.ice,$(OBJDIR)/%.$(langext),$(SLICE_SRCS))
endif

endif

#
# If PRIVATE_SLICE_SRCS is specified, compute the derived headers and
# sources to add them to HEADERS/SRCS.
#
ifneq ($(PRIVATE_SLICE_SRCS),)
PRIVATE_SLICE_SRCS := $(addprefix $(slicedir)/,$(PRIVATE_SLICE_SRCS))

HEADERS += $(patsubst $(slicedir)/%.ice,$(OBJDIR)/include/%.h,$(PRIVATE_SLICE_SRCS))
SRCS    += $(patsubst $(slicedir)/%.ice,$(OBJDIR)/%.$(langext),$(PRIVATE_SLICE_SRCS))
endif


#
# If HEADER_DIRS is specified, add the $(langdir)/include/DIR/*.h
# headers to the HEADERS variable.
#
ifneq ($(HEADER_DIRS),)
exclude = $(patsubst $(slicedir)/%.ice,%.h,$(SLICE_SRCS) $(PRIVATE_SLICE_SRCS))
exclude := $(addprefix %/,$(exclude))

HEADERS += $(subst $(langdir)/include,$(includedir),$(foreach h,$(HEADER_DIRS),$(filter-out $(exclude),$(wildcard $(langdir)/include/$(h)/*.h))))
endif

#
# If SRC_DIRS is specified, add the $(langdir)/src/DIR/*.[cpp|m|mm]
# source files to the SRCS variable..
#
ifneq ($(SRC_DIRS),)
exclude = $(patsubst $(slicedir)/%.ice,%.$(langext),$(SLICE_SRCS) $(PRIVATE_SLICE_SRCS))
exclude += $(EXCLUDE_SRCS)
exclude := $(addprefix %/,$(exclude))

SRCS += $(foreach l,cpp m mm,$(foreach s,$(SRC_DIRS),$(filter-out $(exclude),$(wildcard $(langdir)/src/$(s)/*.$(l)))))
endif

ifneq ($(LOCAL_SRCS),)
SRCS += $(addprefix ./,$(LOCAL_SRCS))
endif

#
# Derive OBJS from SRCS or SRCS from OBJS
#
# Compute the list of objects from the SRCS variable if OBJS isn't
# set. We remove the source directory prefix and add a unique suffix
# to ensure the object file names are unique. For example, for the
# ../../../../cpp/src/Ice/TcpEndpointI.cpp source file, the object
# file will be $(OBJDIR)/Ice/TcpEndpointI_Ice_cpp.o
#
# If OBJS is set but not SRCS derive the sources from the list of
# objects. This is required for tests which specify the objects
# instead of the sources.
#
srcdirs 	= $(langdir)/src . $(OBJDIR) # Directories where sources are located
mkobjname   = $(OBJDIR)/$(if $(subst ./,,$(dir $1)),$(basename $1)_$(subst /,_,$(dir $1))$(subst .,,$(suffix $1)),$(basename $1)).o
mkobjs		= $(foreach d,$(srcdirs),$(foreach f,$(patsubst $(d)/%,%,$(filter $(d)/%,$1)),$(call mkobjname,$f)))
ifeq ($(OBJS),)
OBJS	 	= $(call mkobjs,$(SRCS))
endif

#
# Compute the list suffixes for object names (_Ice_sdk_cpp.o,
# _IceUtil_cpp.o, etc) and create the list of the patterns to
# use as object targets for object implict rules below (e.g.:
# $(OBJDIR)/%_IceUtil_cpp.o $(OBJDIR)/%_Ice_cpp.o ...)
#
unique		 = $(if $1,$(firstword $1) $(call unique,$(filter-out $(firstword $1),$1)))
objsuffixes  = $(call unique,$(foreach f,$(OBJS),$(patsubst $(firstword $(subst _, ,$f))_%,%,$f)))
objpatterns  = $(foreach s,$(objsuffixes),$(OBJDIR)/%_$(s))

#
# Return a list of patterns matching the given pattern, For
# example calling:
#
#   $(call mkobjtargetpattern,$(OBJDIR)/%_cpp.o)
#
# will return:
#
#   iphoneos/%_IceUtil_cpp.o iphoneos/%_Ice_cpp.o ...
#
mkobjtargetpattern = $(filter $1,$(objpatterns))

#
# Include dependencies for slice files and objects
#
ifneq ($(SLICE_SRCS),)
-include $(addprefix $(dependdir)/, $(notdir $(SLICE_SRCS:.ice=.ice.d)))
endif
ifneq ($(PRIVATE_SLICE_SRCS),)
-include $(addprefix $(dependdir)/, $(notdir $(PRIVATE_SLICE_SRCS:.ice=.ice.d)))
endif
ifneq ($(OBJS),)
-include $(addprefix $(dependdir)/, $(notdir $(OBJS:.o=.d)))
endif

#
# If there's no dependency, make sure that objects depend on all the
# headers and sources.
#
ifneq ($(OBJS),)
ifeq ($(wildcard $(dependdir)/*.d),)
$(OBJS): $(HEADERS) | $(OBJDIR)
endif
endif

slice2objc = $(call mkslice,$1,$2,$3,$4,$(if $5,$5,$(SLICE2OBJCFLAGS)),$(SLICE2OBJC))
slice2cpp  = $(call mkslice,$1,$2,$3,$4,$(if $5,$5,$(SLICE2CPPFLAGS)),$(SLICE2CPP))

CXX_CPPFLAGS 	= $(CPPFLAGS)
OBJC_CPPFLAGS 	= $(CPPFLAGS)
OBJCXX_CPPFLAGS = $(CXX_CPPFLAGS)

$(TARGETS): | $(HEADERS)

$(libdir)/$(LIBNAME): $(OBJS)
	@$(call mklib,$@,$(OBJS))

$(OBJDIR):
	@mkdir -p $(OBJDIR)

# Generated C++ source
$(call mkobjtargetpattern,$(OBJDIR)/%_cpp.o): $(OBJDIR)/%.cpp
	@$(call mkobj,$<,$@,-I$(OBJDIR)/include $(CXX_CPPFLAGS))

# Generated Objective-C source
$(call mkobjtargetpattern,$(OBJDIR)/%_m.o): $(OBJDIR)/%.m
	@$(call mkobj,$<,$@,$(OBJC_CPPFLAGS),$(CC))

# C++ source
$(call mkobjtargetpattern,$(OBJDIR)/%_cpp.o): $(cppdir)/src/%.cpp
	@$(call mkobj,$<,$@,-I$(cppdir)/src $(CXX_CPPFLAGS))

# Objective-C source
$(call mkobjtargetpattern,$(OBJDIR)/%_m.o): $(objcdir)/src/%.m
	@$(call mkobj,$<,$@,-I$(objcdir)/src $(OBJC_CPPFLAGS),$(CC))

# Objective-C++ source from C++ source directory
$(call mkobjtargetpattern,$(OBJDIR)/%_mm.o): $(cppdir)/src/%.mm
	@$(call mkobj,$<,$@,-I$(cppdir)/src $(OBJCXX_CPPFLAGS))

# Compile public Slice files from slice directory to C++
$(includedir)/%.h $(OBJDIR)/%.cpp: $(slicedir)/%.ice $(SLICE2CPP)
	@$(call slice2cpp,$<,$(*F),$(includedir)/$(*D),$(OBJDIR)/$(*D),--include-dir $(*D) $(SLICE2CPPFLAGS))

# Compile private Slice files from slice directory to C++
$(OBJDIR)/include/%.h $(OBJDIR)/%.cpp: $(slicedir)/%.ice $(SLICE2CPP)
	@$(call slice2cpp,$<,$(*F),$(OBJDIR)/include/$(*D),$(OBJDIR)/$(*D),--include-dir $(*D) $(SLICE2CPPFLAGS))

# Compile public Slice files from slice directory to Objective-C
$(includedir)/objc/%.h $(OBJDIR)/%.m: $(slicedir)/%.ice $(SLICE2OBJC)
	@$(call slice2objc,$<,$(*F),$(includedir)/objc/$(*D),$(OBJDIR)/$(*D),--include-dir objc/$(*D) $(SLICE2OBJCFLAGS))

# Copy headers from $(langdir)/include to the SDK include directory
ifneq ($(includedir),$(langdir)/include)
$(includedir)/%.h: $(langdir)/include/%.h
	@$(call mkheader,$<,$@)
endif

#
# Rules for building C++ tests (executables for OS X, bundles for iOS)
#
ifneq ($(findstring test/,$(CURDIR)),)

ifeq ($(COMPILE_FOR_IPHONE),yes)

mktestname2	= $(if $(subst $(ice_language),,$(lastword $1)),$(call mktestname2,$(wordlist 2,$(words $1),x $1),$(lastword $1)_$2),$(top_srcdir)/test/cpp/iPhone/container/Bundles-$(OBJDIR)/$2.bundle/lib$2.dylib)
mktestname = $(call mktestname2,$(subst /, ,$(CURDIR)),$(1))
mktest 	   = bundledir=$(dir $(1)); libname=$(notdir $(basename $(1))); \
			 if test ! -f $$bundledir/Info.plist ; \
			 then \
				mkdir -p $$bundledir ; \
				sed "s/NAME/$$libname/" $(top_srcdir)/test/cpp/iPhone/container/BundleInfo.plist > \
						$$bundledir/Info.plist ; \
			 fi ;\
			 $(CXX) -bundle $(LDPLATFORMFLAGS) $(CXXFLAGS) -L$(libdir) -o $(1) $(2) $(3)
else

mktestname	= $(1)
mktest 	  	= $(CXX) $(LDFLAGS) -o $(@) $(2) $(3)

endif

COBJS 		:= $(if $(COBJS),$(addprefix $(OBJDIR)/, $(COBJS)))
SOBJS 		:= $(if $(SOBJS),$(addprefix $(OBJDIR)/, $(SOBJS)))
SAMDOBJS	:= $(if $(SAMDOBJS),$(addprefix $(OBJDIR)/, $(SAMDOBJS)))
COLOBJS 	:= $(if $(COLOBJS),$(addprefix $(OBJDIR)/, $(COLOBJS)))
SLICE_OBJS 	:= $(if $(SLICE_OBJS),$(addprefix $(OBJDIR)/, $(SLICE_OBJS)))

ICECPPFLAGS	:= -I$(testdir) $(ICECPPFLAGS)
CPPFLAGS 	:= -I$(OBJDIR)/include -I$(langdir)/test/include -I$(testdir) $(CPPFLAGS)

#
# It's important that the two following rules appear first, otherwise
# we could endup compiling generated sources from the test directory
# instead of compiling the source from $(OBJDIR).
#
%.o: %.cpp
	@$(call mkobj,$<,$@,$(CXX_CPPFLAGS))

%.o: %.m
	@$(call mkobj,$<,$@,$(OBJC_CPPFLAGS))

$(OBJDIR)/%.o: $(testdir)/%.cpp
	@$(call mkobj,$<,$@,$(CXX_CPPFLAGS))

$(OBJDIR)/%.o: $(testdir)/%.m
	@$(call mkobj,$<,$@,-I$(langdir)/test/Ice $(OBJC_CPPFLAGS))

$(OBJDIR)/include/%.h $(OBJDIR)/%.cpp: $(testdir)/%.ice $(SLICE2CPP)
	@$(call slice2cpp,$<,$(*F),$(OBJDIR)/include,$(OBJDIR),$(SLICE2CPPFLAGS))

$(OBJDIR)/include/%.h $(OBJDIR)/%.m: $(testdir)/%.ice $(SLICE2OBJC)
	@$(call slice2objc,$<,$(*F),$(OBJDIR)/include,$(OBJDIR),$(SLICE2OBJCFLAGS))

# Make sure the tests executables depend on the SDK static library.
$(TARGETS):	$(libdir)/$(call mklibname,$(if $(ice_language:cpp=),IceObjC,Ice))

endif

ifneq ($(TARGETS),)
all:: $(TARGETS)

clean::
	-rm -f $(TARGETS)
endif

clean::
	-rm -rf $(OBJDIR)

install::
